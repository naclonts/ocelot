#!/usr/bin/env python3
"""
Generate photo background textures for the scenario generator via Runware AI
(gpt-image-1.5 model).

Backgrounds are used as wall textures in Gazebo simulation episodes.
The script skips files that already exist, so it is safe to re-run after
interruptions.  After all images are written it regenerates
backgrounds_manifest.json, merging plain-color entries (written by
generate_backgrounds.py) with the real Unsplash photos and AI-generated ones.

Usage:
    source .venv/bin/activate
    python3 sim/scenario_generator/generate_bg_images.py
    python3 sim/scenario_generator/generate_bg_images.py --dry-run

Requirements:
    pip install requests pillow numpy  (all in .venv)
    RUNWARE_API_KEY in .env or shell environment
"""

import argparse
import base64
import json
import os
import sys
import time
import uuid as _uuid_mod
from pathlib import Path

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------

_PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
_BACKGROUNDS_DIR = _PROJECT_ROOT / "sim" / "assets" / "backgrounds"
_MANIFEST_PATH = _PROJECT_ROOT / "sim" / "scenario_generator" / "backgrounds_manifest.json"

# ---------------------------------------------------------------------------
# Runware config
# ---------------------------------------------------------------------------

_RUNWARE_API_URL = "https://api.runware.ai/v1"
_MODEL_ID = "openai:4@1"   # gpt-image-1.5 via Runware

# ---------------------------------------------------------------------------
# Real Unsplash photos (manually placed — not generated by this script).
# Included here so the manifest is complete after one run.
# ---------------------------------------------------------------------------

REAL_PHOTOS = [
    {"id": "outdoor_hills",           "tags": ["outdoor"],        "file": "outdoor_hills.jpg"},
    {"id": "indoor_bedroom_cluttered","tags": ["indoor", "busy"], "file": "indoor_bedroom_cluttered.jpg"},
    {"id": "indoor_workshop_cluttered","tags": ["indoor", "busy"],"file": "indoor_workshop_cluttered.jpg"},
]

# ---------------------------------------------------------------------------
# AI-generated scenes: (id, tags, prompt)
# Images are 1536×1024 landscape JPEGs. No people in any prompt.
# ---------------------------------------------------------------------------

SCENES = [
    # ── Indoor simple ────────────────────────────────────────────────────────
    (
        "indoor_office_minimal",
        ["indoor"],
        "A clean minimalist modern office interior. White painted wall behind a single "
        "wooden desk with a closed laptop. Soft diffused natural light from a side window. "
        "No people. Photorealistic interior photography.",
    ),
    (
        "indoor_living_room",
        ["indoor"],
        "A simple living room interior. Neutral beige sofa against a warm cream wall, "
        "sheer curtains with soft afternoon sunlight filtering through. Tidy, uncluttered. "
        "No people. Photorealistic interior photography.",
    ),
    # ── Indoor complex ───────────────────────────────────────────────────────
    (
        "indoor_office_busy",
        ["indoor", "busy"],
        "A cluttered busy office workspace. Dual computer monitors, stacks of papers and "
        "folders everywhere, overflowing bookshelf packed with binders and books in the "
        "background. No people. Photorealistic.",
    ),
    (
        "indoor_kitchen",
        ["indoor", "busy"],
        "A cozy home kitchen. Wooden cabinet doors, kitchen appliances on the counter, "
        "pots and pans, hanging utensils, open shelves with jars. No people. "
        "Photorealistic interior photography.",
    ),
    (
        "indoor_library",
        ["indoor", "busy"],
        "A library interior aisle. Floor-to-ceiling wooden bookshelves on both sides "
        "packed tightly with books of varied colors and sizes. Warm overhead lighting. "
        "No people. Photorealistic.",
    ),
    (
        "indoor_gym",
        ["indoor", "busy"],
        "A gym interior. Exercise machines visible in the background, a weight rack with "
        "dumbbells, large mirrors on the wall reflecting the equipment. Fluorescent "
        "lighting. No people. Photorealistic.",
    ),
    (
        "indoor_cafe",
        ["indoor", "busy"],
        "A cozy café interior. Wooden tables and chairs, a chalkboard menu on the wall, "
        "warm pendant lighting overhead, coffee cups and pastries on display. No people. "
        "Photorealistic interior photography.",
    ),
    # ── Outdoor simple ───────────────────────────────────────────────────────
    (
        "outdoor_open_sky",
        ["outdoor"],
        "Wide open blue sky with scattered light white cumulus clouds. Flat horizon line "
        "at the bottom quarter. Bright midday sun. No buildings, no trees, no people. "
        "Photorealistic wide landscape photograph.",
    ),
    (
        "outdoor_field",
        ["outdoor"],
        "An open grassy meadow stretching to the horizon under a clear blue sky. "
        "Flat green grass in the foreground, no trees visible. Golden hour light. "
        "No people. Photorealistic landscape photograph.",
    ),
    # ── Outdoor medium ───────────────────────────────────────────────────────
    (
        "outdoor_park",
        ["outdoor"],
        "A park path with wooden benches on the sides, green lawn, and a light tree "
        "canopy overhead. Dappled sunlight on the path. No people. "
        "Photorealistic outdoor photograph.",
    ),
    # ── Outdoor complex ──────────────────────────────────────────────────────
    (
        "outdoor_street",
        ["outdoor", "busy"],
        "A busy city sidewalk with varied storefronts, colorful shop signs, and rich "
        "urban texture. Buildings lining both sides of the street. Overcast light. "
        "No people. Photorealistic street photography.",
    ),
    (
        "outdoor_forest",
        ["outdoor", "busy"],
        "A dense forest path through tall trees. Green leafy canopy, dappled light "
        "filtering through the leaves, mossy ground. Deep perspective into the forest. "
        "No people. Photorealistic nature photograph.",
    ),
    (
        "outdoor_garden",
        ["outdoor", "busy"],
        "A well-tended garden with colorful flower beds and trimmed hedges. A winding "
        "gravel path leads through blooming flowers of many colors. Bright daylight. "
        "No people. Photorealistic outdoor photograph.",
    ),
    (
        "outdoor_cityscape",
        ["outdoor", "busy"],
        "A city street-level view showing varied urban architecture — office buildings, "
        "apartments, and shopfronts. Clear blue sky above, concrete sidewalk below. "
        "No people. Photorealistic architectural photograph.",
    ),
]

# ---------------------------------------------------------------------------
# .env loader
# ---------------------------------------------------------------------------

def _load_dotenv() -> None:
    env_path = _PROJECT_ROOT / ".env"
    if not env_path.exists():
        return
    try:
        from dotenv import load_dotenv
        load_dotenv(env_path, override=False)
        return
    except ImportError:
        pass
    with open(env_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, _, value = line.partition("=")
            os.environ.setdefault(key.strip(), value.strip().strip('"').strip("'"))


# ---------------------------------------------------------------------------
# Runware image generation
# ---------------------------------------------------------------------------

def _generate_runware(api_key: str, scene_id: str, prompt: str) -> bytes:
    try:
        import requests as _requests
    except ImportError:
        print("ERROR: requests package not installed.  Run: pip install requests", file=sys.stderr)
        sys.exit(1)

    payload = [{
        "taskType":       "imageInference",
        "taskUUID":       str(_uuid_mod.uuid4()),
        "model":          _MODEL_ID,
        "positivePrompt": prompt,
        "width":          1536,
        "height":         1024,
        "numberResults":  1,
        "outputType":     ["base64Data"],
        "outputFormat":   "JPEG",
        "providerSettings": {
            "openai": {
                "quality": "high",
            }
        },
    }]

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type":  "application/json",
    }

    delay = 5.0
    for attempt in range(1, 6):
        try:
            resp = _requests.post(_RUNWARE_API_URL, json=payload, headers=headers, timeout=120)
            resp.raise_for_status()
            body = resp.json()

            results = body.get("data") or body.get("results") or []
            if not results:
                raise ValueError(f"Empty result from Runware: {body}")

            result = results[0]
            if "error" in result:
                raise ValueError(f"Runware task error: {result['error']}")

            b64 = result.get("imageBase64Data") or result.get("base64Data")
            if b64:
                return base64.b64decode(b64)

            url = result.get("imageURL")
            if url:
                img_resp = _requests.get(url, timeout=60)
                img_resp.raise_for_status()
                return img_resp.content

            raise ValueError(f"No image data in Runware result: {result}")

        except Exception as exc:
            is_rate_limit = "429" in str(exc) or "rate_limit" in str(exc).lower()
            if attempt == 5:
                raise
            wait = delay * (2 ** (attempt - 1)) if is_rate_limit else delay
            label = "rate limit" if is_rate_limit else f"{type(exc).__name__}: {exc}"
            print(f"  [{scene_id}] {label} (attempt {attempt}/5) — waiting {wait:.0f}s")
            time.sleep(wait)

    raise RuntimeError("unreachable")


# ---------------------------------------------------------------------------
# Manifest rebuild
# ---------------------------------------------------------------------------

def _rebuild_manifest(generated_ids: set[str]) -> None:
    """Merge plain-color entries from existing manifest with real photos
    and newly generated AI images, then write backgrounds_manifest.json."""

    # Load existing manifest (has plain-color entries from generate_backgrounds.py)
    existing = []
    if _MANIFEST_PATH.exists():
        existing = json.loads(_MANIFEST_PATH.read_text())

    plain_entries = [e for e in existing if "plain" in e.get("tags", [])]

    real_entries = [
        e for e in REAL_PHOTOS
        if (_BACKGROUNDS_DIR / e["file"]).exists()
    ]

    ai_entries = [
        {"id": scene_id, "tags": tags, "file": f"{scene_id}.jpg"}
        for scene_id, tags, _ in SCENES
        if (_BACKGROUNDS_DIR / f"{scene_id}.jpg").exists()
    ]

    merged = plain_entries + real_entries + ai_entries
    _MANIFEST_PATH.write_text(json.dumps(merged, indent=2) + "\n")

    n_plain  = len(plain_entries)
    n_real   = len(real_entries)
    n_ai     = len(ai_entries)
    print(f"\nManifest: {len(merged)} total  (plain={n_plain}  real={n_real}  ai={n_ai})")
    print(f"  → {_MANIFEST_PATH}")


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Generate photo background textures via Runware (gpt-image-1.5)."
    )
    parser.add_argument("--dry-run", action="store_true",
                        help="Print what would be generated without calling the API.")
    parser.add_argument("--start", type=int, default=0,
                        help="0-based index of first scene to process (default: 0).")
    parser.add_argument("--limit", "-n", type=int, default=None,
                        help="Maximum number of images to generate (skips count toward limit).")
    parser.add_argument("--delay", type=float, default=1.0,
                        help="Seconds to wait between API calls (default: 1.0).")
    args = parser.parse_args()

    if args.dry_run:
        print(f"Dry run — {len(SCENES)} AI scenes + {len(REAL_PHOTOS)} real photos")
        print(f"  model  : gpt-image-1.5 via Runware  ({_MODEL_ID})")
        print(f"  size   : 1536×1024 JPEG  quality=high")
        print(f"  out    : {_BACKGROUNDS_DIR}")
        print()
        for scene_id, tags, prompt in SCENES:
            out_path = _BACKGROUNDS_DIR / f"{scene_id}.jpg"
            status = "EXISTS" if out_path.exists() else "to generate"
            print(f"  [{scene_id}]  {status}  tags={tags}")
            print(f"    {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
        print()
        print("Real photos (must be placed manually):")
        for e in REAL_PHOTOS:
            exists = (_BACKGROUNDS_DIR / e["file"]).exists()
            print(f"  {e['file']}  {'✓' if exists else 'MISSING'}")
        return

    _load_dotenv()
    api_key = os.environ.get("RUNWARE_API_KEY")
    if not api_key:
        print(
            "ERROR: RUNWARE_API_KEY not set.\n"
            f"  Add it to {_PROJECT_ROOT / '.env'}  or export it in your shell.",
            file=sys.stderr,
        )
        sys.exit(1)

    _BACKGROUNDS_DIR.mkdir(parents=True, exist_ok=True)

    total     = len(SCENES)
    skipped   = 0
    generated = 0
    failed    = []
    limit     = args.limit

    print(f"Generating {total} background image(s) → {_BACKGROUNDS_DIR}")
    print(f"  model=gpt-image-1.5  provider=runware  quality=high  size=1536×1024  delay={args.delay}s")
    print()

    scenes = SCENES[args.start:]

    for idx, (scene_id, tags, prompt) in enumerate(scenes, start=args.start + 1):
        out_path = _BACKGROUNDS_DIR / f"{scene_id}.jpg"
        prefix = f"[{idx:>{len(str(total))}}/{total}] {scene_id}"

        if out_path.exists():
            print(f"{prefix}  SKIP (already exists)")
            skipped += 1
            continue

        if limit is not None and generated >= limit:
            break

        print(f"{prefix}  generating...", end="", flush=True)
        t0 = time.monotonic()

        try:
            img_bytes = _generate_runware(api_key, scene_id, prompt)
        except Exception as exc:
            print(f"\n  ERROR: {exc}")
            failed.append(scene_id)
            continue

        out_path.write_bytes(img_bytes)
        elapsed = time.monotonic() - t0
        print(f"  done ({elapsed:.1f}s, {len(img_bytes)//1024} KB)")
        generated += 1

        if idx < args.start + len(scenes) and args.delay > 0:
            time.sleep(args.delay)

    print()
    print(f"Done.  generated={generated}  skipped={skipped}  failed={len(failed)}")
    if failed:
        print(f"  Failed IDs: {', '.join(failed)}")

    _rebuild_manifest(set())

    if failed:
        sys.exit(1)


if __name__ == "__main__":
    main()
