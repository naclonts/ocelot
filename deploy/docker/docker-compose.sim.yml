services:
  sim:
    build:
      context: ../../
      dockerfile: deploy/docker/Dockerfile.sim
    environment:
      - DISPLAY=${DISPLAY}
      # X11 auth cookie — created on the host with the one-time setup command below.
      # Without this, the container (running as root) is refused by the X server
      # even when DISPLAY is set, causing Gazebo's Qt GUI to crash on startup.
      - XAUTHORITY=/tmp/.docker.xauth
      - ROS_DOMAIN_ID=1          # isolated from real-robot stack (ROS_DOMAIN_ID=0)
      # Prevents Qt from using MIT-SHM extension, which fails in containers and
      # causes rendering artifacts / black windows.
      - QT_X11_NO_MITSHM=1
      # Without GZ_IP, Gazebo transport tries multicast discovery on all interfaces.
      # This stalls the GUI event loop waiting for the server — window appears but
      # freezes before the scene loads.  Binding to loopback fixes it.
      - GZ_IP=127.0.0.1
      # Software rendering fallback (safe default — works on any host).
      # OGRE2's EGL backend auto-detects no hardware device when /dev/dri is absent
      # and falls back to EGL surfaceless.  These vars make Mesa llvmpipe explicit
      # so Qt/GL apps (rqt, rviz2) also stay on the software path.
      # Override via docker-compose.sim.gpu.yml for NVIDIA-accelerated rendering.
      - LIBGL_ALWAYS_SOFTWARE=1
      - GALLIUM_DRIVER=llvmpipe
      - MESA_LOADER_DRIVER_OVERRIDE=llvmpipe
      - EGL_PLATFORM=surfaceless
    volumes:
      - /tmp/.X11-unix:/tmp/.X11-unix  # X11 socket for Gazebo GUI forwarding
      # Wildcard xauth cookie so the container's root user can connect to the host X server.
      # One-time host setup (re-run if the display session changes):
      #   touch /tmp/.docker.xauth
      #   xauth nlist $DISPLAY | sed -e 's/^..../ffff/' | xauth -f /tmp/.docker.xauth nmerge -
      - /tmp/.docker.xauth:/tmp/.docker.xauth
      - ../../:/ws/src/ocelot           # live source mount
      - sim_build:/ws/build
      - sim_install:/ws/install
    # /dev/dri is intentionally absent here.  When present without the NVIDIA
    # container runtime, OGRE2's EGL backend crashes (segfault in driCreateNewScreen3)
    # because no GPU kernel module is initialised in the container.  The GPU override
    # (docker-compose.sim.gpu.yml) adds /dev/dri together with the NVIDIA runtime
    # so both are initialised correctly.
    network_mode: host
    # Gazebo Harmonic's OGRE renderer transfers render buffers between its server
    # and GUI processes via shared memory.  Docker's default /dev/shm is 64 MB —
    # far too small; Gazebo silently fails to render and shows a black window.
    shm_size: '2g'
    # Share the host IPC namespace so the container can access DRI shared memory
    # objects.  Required for hardware-accelerated rendering via /dev/dri.
    ipc: host
    stdin_open: true
    tty: true

volumes:
  sim_build:
  sim_install:
