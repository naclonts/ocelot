services:
  sim:
    build:
      context: ../../
      dockerfile: deploy/docker/Dockerfile.sim
    environment:
      - DISPLAY=${DISPLAY}
      # X11 auth cookie — created on the host with the one-time setup command below.
      # Without this, the container (running as root) is refused by the X server
      # even when DISPLAY is set, causing Gazebo's Qt GUI to crash on startup.
      - XAUTHORITY=/tmp/.docker.xauth
      - ROS_DOMAIN_ID=1          # isolated from real-robot stack (ROS_DOMAIN_ID=0)
      # Prevents Qt from using MIT-SHM extension, which fails in containers and
      # causes rendering artifacts / black windows.
      - QT_X11_NO_MITSHM=1
      # Without GZ_IP, Gazebo transport tries multicast discovery on all interfaces.
      # This stalls the GUI event loop waiting for the server — window appears but
      # freezes before the scene loads.  Binding to loopback fixes it.
      - GZ_IP=127.0.0.1
    volumes:
      - /tmp/.X11-unix:/tmp/.X11-unix  # X11 socket for Gazebo GUI forwarding
      # Wildcard xauth cookie so the container's root user can connect to the host X server.
      # One-time host setup (re-run if the display session changes):
      #   touch /tmp/.docker.xauth
      #   xauth nlist $DISPLAY | sed -e 's/^..../ffff/' | xauth -f /tmp/.docker.xauth nmerge -
      - /tmp/.docker.xauth:/tmp/.docker.xauth
      - ../../:/ws/src/ocelot           # live source mount
      - sim_build:/ws/build
      - sim_install:/ws/install
    # /dev/dri is intentionally not mounted.  When the render node is present,
    # OGRE2's EGL backend calls eglGetPlatformDisplay(EGL_PLATFORM_DEVICE_EXT,
    # hw_device) and the hardware gallium driver crashes (segfault in
    # driCreateNewScreen3) because no GPU kernel module is initialised inside
    # the container.  Without /dev/dri, eglQueryDevicesEXT() finds no hardware
    # device, OGRE2 falls back to EGL surfaceless, and Mesa llvmpipe is used
    # instead.  Re-add the section below only if hardware-accelerated Gazebo
    # GUI is needed on a properly configured GPU-passthrough host:
    #   devices:
    #     - /dev/dri:/dev/dri
    network_mode: host
    # Gazebo Harmonic's OGRE renderer transfers render buffers between its server
    # and GUI processes via shared memory.  Docker's default /dev/shm is 64 MB —
    # far too small; Gazebo silently fails to render and shows a black window.
    shm_size: '2g'
    # Share the host IPC namespace so the container can access DRI shared memory
    # objects.  Required for hardware-accelerated rendering via /dev/dri.
    ipc: host
    stdin_open: true
    tty: true

volumes:
  sim_build:
  sim_install:
